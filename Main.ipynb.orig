{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": 1,
   "metadata": {
    "collapsed": false
   },
   "outputs": [
    {
     "ename": "ImportError",
     "evalue": "No module named pandas",
     "output_type": "error",
     "traceback": [
      "\u001b[1;31m---------------------------------------------------------------------------\u001b[0m",
      "\u001b[1;31mImportError\u001b[0m                               Traceback (most recent call last)",
      "\u001b[1;32m<ipython-input-1-d6ac987968b6>\u001b[0m in \u001b[0;36m<module>\u001b[1;34m()\u001b[0m\n\u001b[1;32m----> 1\u001b[1;33m \u001b[1;32mimport\u001b[0m \u001b[0mpandas\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0m",
      "\u001b[1;31mImportError\u001b[0m: No module named pandas"
     ]
    }
   ],
   "source": [
    "import pandas"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "collapsed": false
   },
   "outputs": [],
   "source": [
    "titanic = pandas.read_csv('train.csv')\n",
    "titanic_test1 = pandas.read_csv('test.csv')\n",
    "titanic_test1.describe()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "collapsed": false
   },
   "outputs": [],
   "source": [
    "titanic_copy = titanic[titanic['Age'].isnull()].copy()\n",
    "titanic_copy"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "collapsed": false
   },
   "outputs": [],
   "source": [
    "titanic.describe()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "collapsed": false
   },
   "outputs": [],
   "source": [
    "#titanic_test.describe()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "collapsed": true
   },
   "outputs": [],
   "source": [
    "titanic['Age'] = titanic['Age'].fillna(titanic['Age'].median())"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "collapsed": false
   },
   "outputs": [],
   "source": [
    "titanic.loc[titanic['Sex'] == 'female', 'Sex'] = 1"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "collapsed": true
   },
   "outputs": [],
   "source": [
    "titanic.loc[titanic['Sex'] == 'male', 'Sex'] = 0"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "collapsed": false
   },
   "outputs": [],
   "source": [
    "titanic['Embarked'] = titanic['Embarked'].fillna('S')"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "collapsed": true
   },
   "outputs": [],
   "source": [
    "titanic.loc[titanic['Embarked'] == 'S', 'Embarked'] = 0\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "collapsed": true
   },
   "outputs": [],
   "source": [
    "titanic.loc[titanic['Embarked'] == 'C', 'Embarked'] = 1\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "collapsed": true
   },
   "outputs": [],
   "source": [
    "titanic.loc[titanic['Embarked'] == 'Q', 'Embarked'] = 2"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# On to machine learning\n",
    "---"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "collapsed": false
   },
   "outputs": [],
   "source": [
    "from sklearn.linear_model import LinearRegression,LogisticRegression"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "collapsed": true
   },
   "outputs": [],
   "source": [
    "from sklearn.cross_validation import KFold"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "collapsed": true
   },
   "outputs": [],
   "source": [
    "predictors = ['Pclass', 'Sex', 'Age', 'SibSp', 'Parch', 'Fare', 'Embarked']"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "collapsed": true
   },
   "outputs": [],
   "source": [
    "alg = LinearRegression()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "collapsed": true
   },
   "outputs": [],
   "source": []
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "collapsed": false
   },
   "outputs": [],
   "source": [
    "kf = KFold(titanic.shape[0], n_folds=3, random_state=1)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "collapsed": false
   },
   "outputs": [],
   "source": [
    "predictions = []"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "?? Why do we need this initialization? \n",
    "# Do predictions(Linear Regressions):\n",
    "---\n",
    "KFold function: is to split the original data set into n_folds train/test data sets. For example, here n_folds = 3 mean it will return 3 train(2/3)/test(1/3) data sets. And after the learning you can combine the test results together to get the final prediction results of the entire original data sets."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "collapsed": false
   },
   "outputs": [],
   "source": [
    "for train, test in kf:\n",
    "    train_predictors = titanic[predictors].iloc[train,:]\n",
    "    train_target = titanic['Survived'].iloc[train]\n",
    "    alg.fit(train_predictors, train_target)\n",
    "    test_predictions = alg.predict(titanic[predictors].iloc[test,:])\n",
    "    predictions.append(test_predictions)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# Evaluating Errors\n",
    "---\n",
    "Error = $\\frac{\\#\\ of\\ correct\\ predictions}{\\#\\ of\\ people}$"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "collapsed": true
   },
   "outputs": [],
   "source": [
    "import numpy as np"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "collapsed": false
   },
   "outputs": [],
   "source": [
    "len(predictions)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "collapsed": false,
    "scrolled": false
   },
   "outputs": [],
   "source": [
    "predictions = np.concatenate(predictions, axis=0)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "collapsed": true
   },
   "outputs": [],
   "source": [
    "predictions[predictions > .5] = 1"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "collapsed": true
   },
   "outputs": [],
   "source": [
    "predictions[predictions <= .5] = 0"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "collapsed": false
   },
   "outputs": [],
   "source": [
    "accuracy = np.sum(predictions[predictions == titanic['Survived']]) / np.size(titanic['Survived'])"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "collapsed": false
   },
   "outputs": [],
   "source": [
    "accuracy"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# Do predictions(Logistic Regression):"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "collapsed": false
   },
   "outputs": [],
   "source": [
    "predicitions_lg = []\n",
    "alg = LogisticRegression(random_state=1)\n",
    "import sklearn.cross_validation as cross_validation"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "collapsed": false
   },
   "outputs": [],
   "source": [
    "scores = cross_validation.cross_val_score(alg, titanic[predictors], titanic['Survived'], cv = 3) "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "collapsed": false
   },
   "outputs": [],
   "source": [
    "np.mean(scores)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# Generating submission file \n",
    "---\n",
    "*  Preprocess test samples"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "collapsed": true
   },
   "outputs": [],
   "source": [
    "titanic_test = pandas.read_csv(\"test.csv\")\n",
    "titanic_test['Age'] = titanic_test['Age'].fillna(titanic['Age'].median())\n",
    "titanic_test.loc[titanic_test['Sex'] == 'male', 'Sex'] = 0\n",
    "titanic_test.loc[titanic_test['Sex'] == 'female', 'Sex'] = 1\n",
    "titanic_test['Embarked'] = titanic_test['Embarked'].fillna('S')\n",
    "titanic_test.loc[titanic_test['Embarked'] == 'S', 'Embarked'] = 0\n",
    "titanic_test.loc[titanic_test['Embarked'] == 'C', 'Embarked'] = 1\n",
    "titanic_test.loc[titanic_test['Embarked'] == 'Q', 'Embarked'] = 2\n",
    "titanic_test['Fare'] = titanic_test['Fare'].fillna(titanic['Fare'].median())"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "*  Train Logistic Model"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "collapsed": true
   },
   "outputs": [],
   "source": [
    "alg = LogisticRegression()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "collapsed": false
   },
   "outputs": [],
   "source": [
    "alg.fit(titanic[predictors], titanic['Survived'])"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "collapsed": false
   },
   "outputs": [],
   "source": [
    "predictions = alg.predict(titanic_test[predictors])"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "collapsed": false
   },
   "outputs": [],
   "source": [
    "submission = pandas.DataFrame({\n",
    "      'PassengerId':titanic_test['PassengerId'],\n",
    "      'Survived': predictions    \n",
    "    })"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "collapsed": true
   },
   "outputs": [],
   "source": [
    "submission.to_csv('kaggle_submission_lg.csv', index=False)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# Do predictions(Random Forest):\n",
    "---"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "collapsed": false
   },
   "outputs": [],
   "source": [
    "from sklearn import cross_validation"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "collapsed": true
   },
   "outputs": [],
   "source": [
    "from sklearn.ensemble import RandomForestClassifier"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "collapsed": true
   },
   "outputs": [],
   "source": [
    "import numpy as np"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "collapsed": true
   },
   "outputs": [],
   "source": [
    "predictors = ['Pclass', 'Sex', 'Age', 'SibSp', 'Parch', 'Fare', 'Embarked']\n",
    "meanscore_array = []"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "collapsed": true
   },
   "outputs": [],
   "source": [
    "alg = RandomForestClassifier(random_state=1, n_estimators=150, min_samples_split=4,\n",
    "       min_samples_leaf=2)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "collapsed": false
   },
   "outputs": [],
   "source": [
    "scores = cross_validation.cross_val_score(alg, titanic[predictors],\n",
    "                                         titanic['Survived'], cv=3)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "collapsed": false
   },
   "outputs": [],
   "source": [
    "scores.mean()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "collapsed": false
   },
   "outputs": [],
   "source": [
    "for i in range(30):\n",
    "    alg = RandomForestClassifier(random_state=1, n_estimators=i+1, min_samples_split=2,\n",
    "       min_samples_leaf=1)\n",
    "    scores = cross_validation.cross_val_score(alg, titanic[predictors],\n",
    "                                         titanic['Survived'], cv=3)\n",
    "    meanscore_array.append(scores.mean())"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "collapsed": false
   },
   "outputs": [],
   "source": [
    "np.argmax(meanscore_array)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Generating new features\n",
    "- FamilySize = SibSp + Parch\n",
    "- NameLength = len(Name)\n",
    "- Title \n",
    "- Family Id,"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "collapsed": true
   },
   "outputs": [],
   "source": [
    "titanic['FamilySize'] = titanic['SibSp'] + titanic['Parch']"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "collapsed": false
   },
   "outputs": [],
   "source": [
    "titanic['NameLength'] = titanic['Name'].apply(lambda x: len(x))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "collapsed": false,
    "scrolled": true
   },
   "outputs": [],
   "source": [
    "import re\n",
    "\n",
    "def get_title(name):\n",
    "    title_search = re.search(' ([A-Za-z]+)\\.', name)\n",
    "    if title_search:\n",
    "        return title_search.group(1)\n",
    "    else:\n",
    "        return ''\n",
    "# Another function used to check another way to write the regular expressions\n",
    "def get_title1(name):\n",
    "    title_search = re.search(' ([A-Za-z]*)\\.', name)\n",
    "    if title_search:\n",
    "        return title_search.group(1)\n",
    "    else:\n",
    "        return ''"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "collapsed": true
   },
   "outputs": [],
   "source": [
    "titles = titanic['Name'].apply(get_title)\n",
    "titles1 = titanic['Name'].apply(get_title)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "collapsed": false
   },
   "outputs": [],
   "source": [
    "for string, string1 in zip(titles, titles1):\n",
    "    if(string != string1):\n",
    "        print string, string1"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "collapsed": false
   },
   "outputs": [],
   "source": [
    "pandas.value_counts(titles)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "collapsed": true
   },
   "outputs": [],
   "source": [
    "title_mapping = {'Mr': 1, 'Miss': 2, 'Mrs': 3, 'Master': 4\n",
    "                , 'Dr': 5, 'Rev': 6, 'Col': 7, 'Major': 8, 'Mlle': 9, 'Countess': 10\n",
    "                , 'Ms': 11, 'Lady': 12, 'Jonkheer': 13, 'Don': 14, 'Mme': 15, 'Capt': 16, \n",
    "                'Sir': 17}"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "collapsed": false
   },
   "outputs": [],
   "source": [
    "for k, v in title_mapping.items():\n",
    "    titles[titles == k] = v"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "collapsed": true
   },
   "outputs": [],
   "source": [
    "titanic['Titles'] = titles"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "collapsed": false
   },
   "outputs": [],
   "source": [
    "titanic['Titles']"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "* Family Groups"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "collapsed": false
   },
   "outputs": [],
   "source": [
    "import operator\n",
    "titanic['Name'].head(10)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "collapsed": false,
    "scrolled": false
   },
   "outputs": [],
   "source": [
    "family_id_mapping = {}\n",
    "operator.itemgetter(1)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "collapsed": true
   },
   "outputs": [],
   "source": [
    "def get_family_id(row):\n",
    "    last_name = row['Name'].split(',')[0]\n",
    "    family_id = '{0}{1}'.format(last_name, row['FamilySize'])\n",
    "    if family_id not in family_id_mapping:\n",
    "        if len(family_id_mapping) == 0:\n",
    "            current_id = 1\n",
    "        else:\n",
    "            # here the operator.itemgetter is used to tell the comparison algo to compare the value/second item in each dict\n",
    "            # ionary entry, \n",
    "            current_id = (max(family_id_mapping.items(), key=operator.itemgetter(1))[1]+1)\n",
    "        family_id_mapping[family_id] = current_id\n",
    "    return family_id_mapping[family_id]"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "collapsed": true
   },
   "outputs": [],
   "source": [
    "family_ids = titanic.apply(get_family_id, axis=1)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "collapsed": true
   },
   "outputs": [],
   "source": [
    "family_ids[titanic['FamilySize'] < 3] = -1"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "collapsed": false
   },
   "outputs": [],
   "source": [
    "pandas.value_counts(family_ids)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "collapsed": false
   },
   "outputs": [],
   "source": [
    "titanic['FamilyId'] = family_ids"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Find out the best features"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "collapsed": true
   },
   "outputs": [],
   "source": [
    "import numpy as np"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "collapsed": false
   },
   "outputs": [],
   "source": [
    "from sklearn.feature_selection import SelectKBest, f_classif"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "collapsed": true
   },
   "outputs": [],
   "source": [
    "predictors = ['Pclass', 'Sex', 'Age', 'SibSp', 'Parch',\n",
    "             'Fare', 'Embarked', 'FamilySize', 'Titles', 'FamilyId']"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "collapsed": true
   },
   "outputs": [],
   "source": [
    "selector = SelectKBest(f_classif, k=5)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "collapsed": false
   },
   "outputs": [],
   "source": [
    "selector.fit(titanic[predictors], titanic['Survived'])"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "collapsed": true
   },
   "outputs": [],
   "source": [
    "scores = -np.log10(selector.pvalues_)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "collapsed": false
   },
   "outputs": [],
   "source": [
    "scores"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "collapsed": false
   },
   "outputs": [],
   "source": [
    "%matplotlib inline\n",
    "import matplotlib.pyplot as plt"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "collapsed": false
   },
<<<<<<< HEAD
   "outputs": [
    {
     "data": {
      "image/png": [
       "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\n"
      ],
      "text/plain": [
       "<matplotlib.figure.Figure at 0x10e4cb0d0>"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    }
   ],
=======
   "outputs": [],
>>>>>>> 5ffed8cf4dbc5465d05cd2a7f0b508e76e28f890
   "source": [
    "plt.bar(range(len(predictors)), scores)\n",
    "plt.xticks(range(len(predictors)), predictors, rotation='vertical')\n",
    "plt.show()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "collapsed": false
   },
   "outputs": [],
   "source": [
    "# Pick only the four best features ??????\n",
    "predictors = ['Pclass', 'Sex', 'Fare', 'Titles']"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "collapsed": true
   },
   "outputs": [],
   "source": [
    "alg = RandomForestClassifier(random_state=1, n_estimators=150,\n",
    "                            min_samples_split=8, min_samples_leaf=4)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "collapsed": true
   },
   "outputs": [],
   "source": [
    "scores = cross_validation.cross_val_score(alg, titanic[predictors], titanic['Survived'], cv=3)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "collapsed": false
   },
   "outputs": [],
   "source": [
    "scores.mean()"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Ensembling Method"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "collapsed": true
   },
   "outputs": [],
   "source": [
    "from sklearn.ensemble import GradientBoostingClassifier"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "collapsed": true
   },
   "outputs": [],
   "source": [
    "algorithms = [\n",
    "    [GradientBoostingClassifier(random_state=1, n_estimators=25, max_depth=3), \n",
    "    ['Pclass', 'Sex', 'Age', 'Fare', 'Embarked', 'FamilySize', 'Titles', 'FamilyId']],\n",
    "    [LogisticRegression(random_state=1), ['Pclass', 'Sex',\n",
    "    'Fare', 'FamilySize', 'Titles', 'Age', 'Embarked']     \n",
    "    ]\n",
    "]"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "collapsed": true
   },
   "outputs": [],
   "source": [
    "kf = KFold(titanic.shape[0], n_folds=3, random_state=1)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "collapsed": true
   },
   "outputs": [],
   "source": [
    "predictions=[]"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "collapsed": false
   },
   "outputs": [],
   "source": [
    "for train, test in kf:\n",
    "    train_target = titanic['Survived'].iloc[train]\n",
    "    full_test_predictions = []\n",
    "    for alg, predictors in algorithms:\n",
    "        alg.fit(titanic[predictors].iloc[train, :], train_target)\n",
    "        test_predictions = alg.predict_proba(titanic[predictors].iloc[test, :])[:, 1]\n",
    "        full_test_predictions.append(test_predictions)\n",
    "    test_predictions = (full_test_predictions[0] + full_test_predictions[1]) / 2\n",
    "    test_predictions[test_predictions > .5] = 1\n",
    "    test_predictions[test_predictions <= .5] = 0\n",
    "    predictions.append(test_predictions)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "collapsed": false
   },
   "outputs": [],
   "source": [
    "predictions = np.concatenate(predictions, axis=0)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "collapsed": false
   },
   "outputs": [],
   "source": [
    "predictions"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "collapsed": false
   },
   "outputs": [],
   "source": [
    "accuracy = sum(predictions[predictions == titanic['Survived']]) / len(predictions)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "collapsed": false
   },
   "outputs": [],
   "source": [
    "accuracy"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# Make predictions on test dataset"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "collapsed": false,
    "scrolled": true
   },
   "outputs": [],
   "source": [
    "# First, we'll add titles to the test set.\n",
    "titles = titanic_test[\"Name\"].apply(get_title)\n",
    "print(titles)\n",
    "# We're adding the Dona title to the mapping, because it's in the test set, but not the training set\n",
    "title_mapping = {\"Mr\": 1, \"Miss\": 2, \"Mrs\": 3, \"Master\": 4, \"Dr\": 5, \"Rev\": 6, \"Major\": 7, \"Col\": 7, \"Mlle\": 8, \"Mme\": 8, \"Don\": 9, \"Lady\": 10, \"Countess\": 10, \"Jonkheer\": 10, \"Sir\": 9, \"Capt\": 7, \"Ms\": 2, \"Dona\": 10}\n",
    "for k,v in title_mapping.items():\n",
    "    titles[titles == k] = v\n",
    "titanic_test[\"Titles\"] = titles\n",
    "# Check the counts of each unique title.\n",
    "print(pandas.value_counts(titanic_test[\"Titles\"]))\n",
    "\n",
    "# Now, we add the family size column.\n",
    "titanic_test[\"FamilySize\"] = titanic_test[\"SibSp\"] + titanic_test[\"Parch\"]\n",
    "\n",
    "# Now we can add family ids.\n",
    "# We'll use the same ids that we did earlier.\n",
    "print(family_id_mapping)\n",
    "\n",
    "family_ids = titanic_test.apply(get_family_id, axis=1)\n",
    "family_ids[titanic_test[\"FamilySize\"] < 3] = -1\n",
    "titanic_test[\"FamilyId\"] = family_ids\n",
    "titanic_test['NameLength'] = titanic_test['Name'].apply(lambda x: len(x))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "collapsed": false
   },
   "outputs": [],
   "source": [
    "predictors = [\"Pclass\", \"Sex\", \"Age\", \"Fare\", \"Embarked\", \"FamilySize\", \"Titles\", \"FamilyId\"]\n",
    "\n",
    "algorithms = [\n",
    "    [GradientBoostingClassifier(random_state=1, n_estimators=25, max_depth=3), predictors],\n",
    "    [LogisticRegression(random_state=1), [\"Pclass\", \"Sex\", \"Fare\", \"FamilySize\", \"Titles\", \"Age\", \"Embarked\"]]\n",
    "]\n",
    "\n",
    "full_predictions = []\n",
    "for alg, predictors in algorithms:\n",
    "    # Fit the algorithm using the full training data.\n",
    "    alg.fit(titanic[predictors], titanic[\"Survived\"])\n",
    "    # Predict using the test dataset.  We have to convert all the columns to floats to avoid an error.\n",
    "    predictions = alg.predict_proba(titanic_test[predictors].astype(float))[:,1]\n",
    "    full_predictions.append(predictions)\n",
    "\n",
    "\n",
    "# The gradient boosting classifier generates better predictions, so we weight it higher.\n",
    "predictions = (full_predictions[0] * 3 + full_predictions[1]) / 4\n",
    "predictions[predictions > 0.5] = 1\n",
    "predictions[predictions <= 0.5] = 0\n",
    "predictions = predictions.astype(int)\n",
    "submission = pandas.DataFrame({\n",
    "    'PassengerId': titanic_test['PassengerId'],\n",
    "    'Survived': predictions\n",
    "    })\n",
    "submission.to_csv('kaggle_gbt.csv', index=False)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "collapsed": false
   },
   "outputs": [],
   "source": [
    "titanic[titanic['Sex'] == 1]"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "collapsed": false,
    "scrolled": true
   },
   "outputs": [],
   "source": [
    "titanic"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "collapsed": true
   },
   "source": [
    "# Use xgboost model to do predictions"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "collapsed": true
   },
   "outputs": [],
   "source": [
    "import xgboost as xgb"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Turn the original data to DMatrix format"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "collapsed": false
   },
   "outputs": [],
   "source": []
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "collapsed": true
   },
   "outputs": [],
   "source": []
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "collapsed": false
   },
   "outputs": [],
   "source": [
    "# Turn the pandas DataFrame to DMatrix format\n",
    "ftrain = open('./titanic.train.dmatrix', 'w')\n",
    "ftest = open('./titanic.test.dmatrix', 'w')\n",
    "for i in range(titanic.shape[0]):\n",
    "    ftrain.write(str(titanic['Survived'].iloc[i]))\n",
    "    ftrain.write(' ')\n",
    "    for j in range(len(predictors)):\n",
    "        ftrain.write(str(j))\n",
    "        ftrain.write(':')\n",
    "        ftrain.write(str(titanic[predictors[j]].iloc[i]))\n",
    "        ftrain.write(' ')\n",
    "    ftrain.write('\\n')\n",
    "for i in range(titanic_test.shape[0]):\n",
    "    ftest.write(str(-1))\n",
    "    ftest.write(' ')\n",
    "    for j in range(len(predictors)):\n",
    "        ftest.write(str(j))\n",
    "        ftest.write(':')\n",
    "        ftest.write(str(titanic_test[predictors[j]].iloc[i]))\n",
    "        ftest.write(' ')\n",
    "    ftest.write('\\n')"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "collapsed": false
   },
   "outputs": [],
   "source": [
    "dtrain = xgb.DMatrix('./titanic.train.dmatrix')"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "collapsed": false
   },
   "outputs": [],
   "source": [
    "params = {'max_depth':3, 'eta':0.5, 'silent':1, 'objective':'binary:logistic'}\n",
    "num_round = 20"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "collapsed": false
   },
   "outputs": [],
   "source": [
    "t = xgb.cv(params, dtrain, num_round, nfold=4, metrics={'error'}, seed=0)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "collapsed": false
   },
   "outputs": [],
   "source": [
    "t"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "collapsed": true
   },
   "outputs": [],
   "source": [
    "bst = xgb.train(params, dtrain, num_round)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "collapsed": false
   },
   "outputs": [],
   "source": [
    "dtest = xgb.DMatrix('./titanic.test.dmatrix')"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "collapsed": true
   },
   "outputs": [],
   "source": [
    "preds = bst.predict(dtest)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "collapsed": false
   },
   "outputs": [],
   "source": [
    "labels = dtest.get_label()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "collapsed": false,
    "scrolled": true
   },
   "outputs": [],
   "source": [
    "preds"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "collapsed": false
   },
   "outputs": [],
   "source": [
    "preds[preds > 0.5] = 1\n",
    "preds[preds <= 0.5] = 0"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "collapsed": false
   },
   "outputs": [],
   "source": [
    "preds"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "collapsed": false
   },
   "outputs": [],
   "source": [
    "predictions = preds.astype(int)\n",
    "submission = pandas.DataFrame({\n",
    "    'PassengerId': titanic_test['PassengerId'],\n",
    "    'Survived': predictions\n",
    "    })\n",
    "submission.to_csv('kaggle_xgboost.csv', index=False)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Test the round number dependent error rate"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "collapsed": false
   },
   "outputs": [],
   "source": [
    "auc_test = []\n",
    "auc_train = []\n",
    "No_round = 100\n",
    "for m in range(No_round):\n",
    "    result = xgb.cv(params, dtrain, m+1, nfold=4, metrics={'error'}, seed=0)   \n",
    "    auc_test.append(result['test-error-mean'].iloc[m])\n",
    "    auc_train.append(result['train-error-mean'].iloc[m])\n",
    "plt.plot(range(No_round), auc_test, color='red')\n",
    "plt.plot(range(No_round), auc_train, color='purple')"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Test the depth dependent error rate(5 should be OK)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "collapsed": false
   },
   "outputs": [],
   "source": [
    "result_test = []\n",
    "result_train = []\n",
    "No_item = 20\n",
    "for m in range(No_item):\n",
    "    params = {'max_depth':m, 'eta':0.5, 'silent':1, 'objective':'binary:logistic'}\n",
    "    result = xgb.cv(params, dtrain, 20, nfold=4, metrics={'error'}, seed=0)   \n",
    "    result_test.append(result['test-error-mean'].iloc[m])\n",
    "    result_train.append(result['train-error-mean'].iloc[m])\n",
    "print min(result_test)\n",
    "print result_test.index(min(result_test))\n",
    "plt.plot(range(No_item), result_test, color='red')\n",
    "plt.plot(range(No_item), result_train, color='purple')"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Test the eta parameter(0.7 should be OK.)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "collapsed": false
   },
   "outputs": [],
   "source": [
    "result_test = []\n",
    "result_train = []\n",
    "No_item = 20\n",
    "for m in range(No_item):\n",
    "    params = {'max_depth':3, 'eta':1./float(No_item)*(m), 'silent':1, 'objective':'binary:logistic'}\n",
    "    result = xgb.cv(params, dtrain, 20, nfold=4, metrics={'error'}, seed=0)   \n",
    "    result_test.append(result['test-error-mean'].iloc[m])\n",
    "    result_train.append(result['train-error-mean'].iloc[m])\n",
    "    print 1/No_item*(m+1)\n",
    "    print result['test-error-mean'].iloc[m]\n",
    "print min(result_test)\n",
    "plt.plot(range(No_item), result_test, color='red')\n",
    "plt.plot(range(No_item), result_train, color='purple')"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "collapsed": false
   },
   "outputs": [],
   "source": [
    "t"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "collapsed": false
   },
   "outputs": [],
   "source": [
    "params = {'subsample':1., 'colsample_bytree':1., 'max_depth':2, 'min_child_weight':4, 'eta':0.7, 'silent':1, 'objective':'binary:logistic'}\n",
    "num_round = 20\n",
    "xgb.cv(params, dtrain, num_round, nfold=3, metrics={'error', 'auc'}, seed=0) "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "collapsed": true
   },
   "outputs": [],
   "source": [
    "bst = xgb.train(params, dtrain, num_round)\n",
    "preds = bst.predict(dtest)\n",
    "preds[preds > 0.5] = 1\n",
    "preds[preds <= 0.5] = 0\n",
    "predictions = preds.astype(int)\n",
    "submission = pandas.DataFrame({\n",
    "    'PassengerId': titanic_test['PassengerId'],\n",
    "    'Survived': predictions\n",
    "    })\n",
    "submission.to_csv('kaggle_xgboost.csv', index=False)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "collapsed": true
   },
   "source": [
    "# Take a look at the age distribution"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "collapsed": true
   },
   "outputs": [],
   "source": [
    "titanic = pandas.read_csv('train.csv')\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "collapsed": false
   },
   "outputs": [],
   "source": [
    "titanic"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "collapsed": true
   },
   "outputs": [],
   "source": [
    "titanic_with_age = titanic[~titanic['Age'].isnull()]"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "collapsed": false
   },
   "outputs": [],
   "source": [
    "titanic_with_age"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "collapsed": false
   },
<<<<<<< HEAD
   "outputs": [
    {
     "data": {
      "text/plain": [
       "(array([  30.,   14.,   10.,   14.,    3.,   29.,   39.,   65.,   73.,\n",
       "          42.,  242.,   62.,   33.,   47.,   38.,   21.,   28.,   21.,\n",
       "          16.,   14.,   15.,    7.,    9.,    8.,    4.,    0.,    5.,\n",
       "           1.,    0.,    1.]),\n",
       " array([  0.42      ,   3.07266667,   5.72533333,   8.378     ,\n",
       "         11.03066667,  13.68333333,  16.336     ,  18.98866667,\n",
       "         21.64133333,  24.294     ,  26.94666667,  29.59933333,\n",
       "         32.252     ,  34.90466667,  37.55733333,  40.21      ,\n",
       "         42.86266667,  45.51533333,  48.168     ,  50.82066667,\n",
       "         53.47333333,  56.126     ,  58.77866667,  61.43133333,\n",
       "         64.084     ,  66.73666667,  69.38933333,  72.042     ,\n",
       "         74.69466667,  77.34733333,  80.        ]),\n",
       " <a list of 30 Patch objects>)"
      ]
     },
     "execution_count": 108,
     "metadata": {},
     "output_type": "execute_result"
    },
    {
     "data": {
      "image/png": [
       "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\n",
       "3AAAAABJRU5ErkJggg==\n"
      ],
      "text/plain": [
       "<matplotlib.figure.Figure at 0x10e5273d0>"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    }
   ],
=======
   "outputs": [],
>>>>>>> 5ffed8cf4dbc5465d05cd2a7f0b508e76e28f890
   "source": [
    "import matplotlib.pyplot as plt\n",
    "plt.hist(titanic_with_age['Age'], 30, facecolor='blue', alpha=0.5)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "collapsed": false
   },
   "outputs": [],
   "source": [
    "fig, axe = plt.subplots()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "collapsed": false
   },
   "outputs": [],
   "source": [
    "(~titanic['Age'].isnull())[0]"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "collapsed": false
   },
   "outputs": [],
   "source": [
    "titanic"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "collapsed": false
   },
   "outputs": [],
   "source": [
    "titanic_with_age['Age'][0]"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "collapsed": true
   },
   "outputs": [],
   "source": []
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 2",
   "language": "python",
   "name": "python2"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 2
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython2",
   "version": "2.7.6"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 0
}
